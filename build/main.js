/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var path = __toESM(require("path"));
var DEFAULT_SETTINGS = {
  autoRename: true,
  convertToWEBP: true,
  convertToJPG: false,
  convertToPNG: false,
  convertTo: "",
  quality: 0.75,
  dirpath: "",
  resizeMode: "None",
  desiredWidth: 600,
  desiredHeight: 800,
  desiredLength: 800
};
var MyPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (!(file instanceof import_obsidian.TFile))
          return;
        const timeGapMs = Date.now() - file.stat.ctime;
        if (timeGapMs > 1e3)
          return;
        if (isImage(file)) {
          console.log("pasted image created", file);
          this.renameFile(file);
        }
      })
    );
    this.addSettingTab(new SampleSettingTab(this.app, this));
  }
  async renameFile(file) {
    const activeFile = this.getActiveFile();
    if (!activeFile) {
      new import_obsidian.Notice("Error: No active file found.");
      return;
    }
    let newName = await this.keepOrgName(file, activeFile);
    if (this.settings.autoRename) {
      newName = await this.generateNewName(file, activeFile);
    }
    const sourcePath = activeFile.path;
    let newPath = "";
    newPath = this.settings.dirpath;
    console.log("newPath is set to:", newPath);
    const originName = file.name;
    const binary = await this.app.vault.readBinary(file);
    const imgBlob = new Blob([binary], { type: `image/${file.extension}` });
    if (this.settings.convertTo === "webp") {
      const arrayBufferWebP = await convertToWebP(
        imgBlob,
        Number(this.settings.quality),
        this.settings.resizeMode,
        this.settings.desiredWidth,
        this.settings.desiredHeight,
        this.settings.desiredLength
      );
      await this.app.vault.modifyBinary(file, arrayBufferWebP);
    } else if (this.settings.convertTo === "jpg") {
      const arrayBufferJPG = await convertToJPG(
        imgBlob,
        Number(this.settings.quality),
        this.settings.resizeMode,
        this.settings.desiredWidth,
        this.settings.desiredHeight,
        this.settings.desiredLength
      );
      await this.app.vault.modifyBinary(file, arrayBufferJPG);
    } else if (this.settings.convertTo === "png") {
      const arrayBufferPNG = await convertToPNG(
        imgBlob,
        Number(this.settings.quality),
        this.settings.resizeMode,
        this.settings.desiredWidth,
        this.settings.desiredHeight,
        this.settings.desiredLength
      );
      await this.app.vault.modifyBinary(file, arrayBufferPNG);
    } else {
      new import_obsidian.Notice("Error: No format selected for conversion.");
      return;
    }
    const linkText = this.makeLinkText(file, sourcePath);
    newPath = path.join(newPath, newName);
    try {
      await this.app.vault.rename(file, newPath);
    } catch (err) {
      new import_obsidian.Notice(`Failed to rename ${newName}: ${err}`);
      throw err;
    }
    const newLinkText = this.makeLinkText(file, sourcePath);
    console.log("replace text", linkText, newLinkText);
    const editor = this.getActiveEditor(sourcePath);
    if (!editor) {
      new import_obsidian.Notice(`Failed to rename ${newName}: no active editor`);
      return;
    }
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    console.log("current line", line);
    editor.transaction({
      changes: [
        {
          from: { ...cursor, ch: 0 },
          to: { ...cursor, ch: line.length },
          text: line.replace(linkText, newLinkText)
        }
      ]
    });
    new import_obsidian.Notice(`Renamed ${originName} to ${newName}`);
  }
  makeLinkText(file, sourcePath, subpath) {
    return this.app.fileManager.generateMarkdownLink(file, sourcePath, subpath);
  }
  async generateNewName(file, activeFile) {
    const newName = activeFile.basename + "-" + new Date().toISOString().replace(/[-:T.Z]/g, "");
    let extension = file.extension;
    if (this.settings.convertTo) {
      extension = this.settings.convertTo;
    }
    return `${newName}.${extension}`;
  }
  async keepOrgName(file, activeFile) {
    const newName = file.basename;
    let extension = file.extension;
    if (this.settings.convertTo) {
      extension = this.settings.convertTo;
    }
    return `${newName}.${extension}`;
  }
  getActiveFile() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const file = view == null ? void 0 : view.file;
    console.log("active file", file == null ? void 0 : file.path);
    if (file) {
      return file;
    }
    return void 0;
  }
  getActiveEditor(sourcePath) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (view && view.file && view.file.path === sourcePath) {
      return view.editor;
    }
    return null;
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
function isImage(file) {
  const IMAGE_EXTS = ["jpg", "jpeg", "png", "webp"];
  return IMAGE_EXTS.includes(file.extension.toLowerCase());
}
function convertToWebP(file, quality, resizeMode, desiredWidth, desiredHeight, desiredLength) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = (e) => {
      if (!e.target || !e.target.result) {
        reject(new Error("Failed to load file"));
        return;
      }
      const image = new Image();
      image.onload = () => {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        if (!context) {
          reject(new Error("Failed to get canvas context"));
          return;
        }
        let imageWidth = 0;
        let imageHeight = 0;
        const aspectRatio = image.naturalWidth / image.naturalHeight;
        switch (resizeMode) {
          case "None":
            imageWidth = image.naturalWidth;
            imageHeight = image.naturalHeight;
            break;
          case "Fit":
            if (aspectRatio > desiredWidth / desiredHeight) {
              imageWidth = desiredWidth;
              imageHeight = imageWidth / aspectRatio;
            } else {
              imageHeight = desiredHeight;
              imageWidth = imageHeight * aspectRatio;
            }
            break;
          case "Fill":
            if (aspectRatio > desiredWidth / desiredHeight) {
              imageHeight = desiredHeight;
              imageWidth = imageHeight * aspectRatio;
            } else {
              imageWidth = desiredWidth;
              imageHeight = imageWidth / aspectRatio;
            }
            break;
          case "LongestSide":
            if (image.naturalWidth > image.naturalHeight) {
              imageWidth = desiredLength;
              imageHeight = imageWidth / aspectRatio;
            } else {
              imageHeight = desiredLength;
              imageWidth = imageHeight * aspectRatio;
            }
            break;
          case "ShortestSide":
            if (image.naturalWidth < image.naturalHeight) {
              imageWidth = desiredLength;
              imageHeight = imageWidth / aspectRatio;
            } else {
              imageHeight = desiredLength;
              imageWidth = imageHeight * aspectRatio;
            }
            break;
          case "Width":
            imageWidth = desiredWidth;
            imageHeight = desiredWidth / aspectRatio;
            break;
          case "Height":
            imageHeight = desiredHeight;
            imageWidth = desiredHeight * aspectRatio;
            break;
        }
        let data = "";
        canvas.width = resizeMode === "Fill" ? desiredWidth : imageWidth;
        canvas.height = resizeMode === "Fill" ? desiredHeight : imageHeight;
        context.fillStyle = "#fff";
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.save();
        context.translate(canvas.width / 2, canvas.height / 2);
        context.drawImage(
          image,
          0,
          0,
          resizeMode === "Fill" ? Math.min(image.naturalWidth, image.naturalHeight * aspectRatio) : image.naturalWidth,
          resizeMode === "Fill" ? Math.min(image.naturalHeight, image.naturalWidth / aspectRatio) : image.naturalHeight,
          -imageWidth / 2,
          -imageHeight / 2,
          resizeMode === "Fill" ? desiredWidth : imageWidth,
          resizeMode === "Fill" ? desiredHeight : imageHeight
        );
        context.restore();
        data = canvas.toDataURL("image/webp", quality);
        const arrayBuffer = base64ToArrayBuffer(data);
        resolve(arrayBuffer);
      };
      image.src = e.target.result.toString();
    };
    reader.readAsDataURL(file);
  });
}
function convertToJPG(imgBlob, quality, resizeMode, desiredWidth, desiredHeight, desiredLength) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = (e) => {
      if (!e.target || !e.target.result) {
        reject(new Error("Failed to load file"));
        return;
      }
      const image = new Image();
      image.onload = () => {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        if (!context) {
          reject(new Error("Failed to get canvas context"));
          return;
        }
        let imageWidth = 0;
        let imageHeight = 0;
        const aspectRatio = image.naturalWidth / image.naturalHeight;
        switch (resizeMode) {
          case "None":
            imageWidth = image.naturalWidth;
            imageHeight = image.naturalHeight;
            break;
          case "Fit":
            if (aspectRatio > desiredWidth / desiredHeight) {
              imageWidth = desiredWidth;
              imageHeight = imageWidth / aspectRatio;
            } else {
              imageHeight = desiredHeight;
              imageWidth = imageHeight * aspectRatio;
            }
            break;
          case "Fill":
            if (aspectRatio > desiredWidth / desiredHeight) {
              imageHeight = desiredHeight;
              imageWidth = imageHeight * aspectRatio;
            } else {
              imageWidth = desiredWidth;
              imageHeight = imageWidth / aspectRatio;
            }
            break;
          case "LongestSide":
            if (image.naturalWidth > image.naturalHeight) {
              imageWidth = desiredLength;
              imageHeight = imageWidth / aspectRatio;
            } else {
              imageHeight = desiredLength;
              imageWidth = imageHeight * aspectRatio;
            }
            break;
          case "ShortestSide":
            if (image.naturalWidth < image.naturalHeight) {
              imageWidth = desiredLength;
              imageHeight = imageWidth / aspectRatio;
            } else {
              imageHeight = desiredLength;
              imageWidth = imageHeight * aspectRatio;
            }
            break;
          case "Width":
            imageWidth = desiredWidth;
            imageHeight = desiredWidth / aspectRatio;
            break;
          case "Height":
            imageHeight = desiredHeight;
            imageWidth = desiredHeight * aspectRatio;
            break;
        }
        let data = "";
        canvas.width = resizeMode === "Fill" ? desiredWidth : imageWidth;
        canvas.height = resizeMode === "Fill" ? desiredHeight : imageHeight;
        context.fillStyle = "#fff";
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.save();
        context.translate(canvas.width / 2, canvas.height / 2);
        context.drawImage(
          image,
          0,
          0,
          resizeMode === "Fill" ? Math.min(image.naturalWidth, image.naturalHeight * aspectRatio) : image.naturalWidth,
          resizeMode === "Fill" ? Math.min(image.naturalHeight, image.naturalWidth / aspectRatio) : image.naturalHeight,
          -imageWidth / 2,
          -imageHeight / 2,
          resizeMode === "Fill" ? desiredWidth : imageWidth,
          resizeMode === "Fill" ? desiredHeight : imageHeight
        );
        context.restore();
        data = canvas.toDataURL("image/jpeg", quality);
        const arrayBuffer = base64ToArrayBuffer(data);
        resolve(arrayBuffer);
      };
      image.src = e.target.result.toString();
    };
    reader.readAsDataURL(imgBlob);
  });
}
function convertToPNG(imgBlob, colorDepth, resizeMode, desiredWidth, desiredHeight, desiredLength) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = (e) => {
      if (!e.target || !e.target.result) {
        reject(new Error("Failed to load file"));
        return;
      }
      const image = new Image();
      image.onload = () => {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        if (!context) {
          reject(new Error("Failed to get canvas context"));
          return;
        }
        let imageWidth = 0;
        let imageHeight = 0;
        const aspectRatio = image.naturalWidth / image.naturalHeight;
        switch (resizeMode) {
          case "None":
            imageWidth = image.naturalWidth;
            imageHeight = image.naturalHeight;
            break;
          case "Fit":
            if (aspectRatio > desiredWidth / desiredHeight) {
              imageWidth = desiredWidth;
              imageHeight = imageWidth / aspectRatio;
            } else {
              imageHeight = desiredHeight;
              imageWidth = imageHeight * aspectRatio;
            }
            break;
          case "Fill":
            if (aspectRatio > desiredWidth / desiredHeight) {
              imageHeight = desiredHeight;
              imageWidth = imageHeight * aspectRatio;
            } else {
              imageWidth = desiredWidth;
              imageHeight = imageWidth / aspectRatio;
            }
            break;
          case "LongestSide":
            if (image.naturalWidth > image.naturalHeight) {
              imageWidth = desiredLength;
              imageHeight = imageWidth / aspectRatio;
            } else {
              imageHeight = desiredLength;
              imageWidth = imageHeight * aspectRatio;
            }
            break;
          case "ShortestSide":
            if (image.naturalWidth < image.naturalHeight) {
              imageWidth = desiredLength;
              imageHeight = imageWidth / aspectRatio;
            } else {
              imageHeight = desiredLength;
              imageWidth = imageHeight * aspectRatio;
            }
            break;
          case "Width":
            imageWidth = desiredWidth;
            imageHeight = desiredWidth / aspectRatio;
            break;
          case "Height":
            imageHeight = desiredHeight;
            imageWidth = desiredHeight * aspectRatio;
            break;
        }
        let data = "";
        canvas.width = resizeMode === "Fill" ? desiredWidth : imageWidth;
        canvas.height = resizeMode === "Fill" ? desiredHeight : imageHeight;
        context.fillStyle = "#fff";
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.save();
        context.translate(canvas.width / 2, canvas.height / 2);
        context.drawImage(
          image,
          0,
          0,
          resizeMode === "Fill" ? Math.min(image.naturalWidth, image.naturalHeight * aspectRatio) : image.naturalWidth,
          resizeMode === "Fill" ? Math.min(image.naturalHeight, image.naturalWidth / aspectRatio) : image.naturalHeight,
          -imageWidth / 2,
          -imageHeight / 2,
          resizeMode === "Fill" ? desiredWidth : imageWidth,
          resizeMode === "Fill" ? desiredHeight : imageHeight
        );
        context.restore();
        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        const reducedImageData = reduceColorDepth(imageData, colorDepth);
        context.putImageData(reducedImageData, 0, 0);
        data = canvas.toDataURL("image/png");
        const arrayBuffer = base64ToArrayBuffer(data);
        resolve(arrayBuffer);
      };
      image.src = e.target.result.toString();
    };
    reader.readAsDataURL(imgBlob);
  });
}
function reduceColorDepth(imageData, colorDepth) {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("Failed to get canvas context");
  }
  canvas.width = imageData.width;
  canvas.height = imageData.height;
  ctx.putImageData(imageData, 0, 0);
  const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
  const numColors = Math.pow(256, colorDepth);
  const reducedData = new Uint8ClampedArray(data.length);
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const reducedR = Math.round(r / (256 / numColors)) * (256 / numColors);
    const reducedG = Math.round(g / (256 / numColors)) * (256 / numColors);
    const reducedB = Math.round(b / (256 / numColors)) * (256 / numColors);
    reducedData[i] = reducedR;
    reducedData[i + 1] = reducedG;
    reducedData[i + 2] = reducedB;
    reducedData[i + 3] = data[i + 3];
  }
  const reducedImageData = new ImageData(reducedData, imageData.width, imageData.height);
  return reducedImageData;
}
function base64ToArrayBuffer(code) {
  const parts = code.split(";base64,");
  const raw = window.atob(parts[1]);
  const rawLength = raw.length;
  const uInt8Array = new Uint8Array(rawLength);
  for (let i = 0; i < rawLength; ++i) {
    uInt8Array[i] = raw.charCodeAt(i);
  }
  return uInt8Array.buffer;
}
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Select format to convert images to").setDesc(`Turn this on to allow image conversion and compression on drag'n'drop or paste.`).addDropdown(
      (dropdown) => dropdown.addOptions({ webp: "WebP", jpg: "JPG", png: "PNG" }).setValue(this.plugin.settings.convertTo).onChange(async (value) => {
        this.plugin.settings.convertTo = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Quality").setDesc("0 - low quality, 100 - high quality, 75 - Recommended").addText(
      (text) => text.setPlaceholder("Enter quality (0-100)").setValue((this.plugin.settings.quality * 100).toString()).onChange(async (value) => {
        const quality = parseInt(value);
        if (/^\d+$/.test(value) && quality >= 0 && quality <= 100) {
          this.plugin.settings.quality = quality / 100;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Image Resize Mode").setDesc("The mode to use when resizing the image").addDropdown(
      (dropdown) => dropdown.addOptions({ None: "None", Fit: "Fit", Fill: "Fill", LongestSide: "Longest Side", ShortestSide: "Shortest Side", Width: "Width", Height: "Height" }).setValue(this.plugin.settings.resizeMode).onChange(async (value) => {
        this.plugin.settings.resizeMode = value;
        await this.plugin.saveSettings();
        if (value !== "None") {
          const modal = new ResizeModal(this.plugin);
          modal.open();
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto Rename").setDesc(
      `Automatically rename dropped image into current notes name + todays date (YYYYMMDDHHMMSS). For instance, image "testImage.jpg" dropped into note "Howtotakenotes.md" becomes "Howtotakenotes-20230927164411.webp"`
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoRename).onChange(async (value) => {
        this.plugin.settings.autoRename = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Image Directory").setDesc("Directory to move processed images to").addText(
      (text) => text.setPlaceholder("Enter directory path").setValue(this.plugin.settings.dirpath).onChange(async (value) => {
        this.plugin.settings.dirpath = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
var ResizeModal = class extends import_obsidian.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    let explanation = "";
    switch (this.plugin.settings.resizeMode) {
      case "Fit":
        explanation = "Fit mode resizes the image to fit within the desired dimensions while maintaining the aspect ratio of the image.";
        break;
      case "Fill":
        explanation = "Fill mode resizes the image to fill the desired dimensions while maintaining the aspect ratio of the image. This may result in cropping of the image.";
        break;
      case "LongestSide":
        explanation = "Longest Side mode resizes the longest side of the image to match the desired length while maintaining the aspect ratio of the image.";
        break;
      case "ShortestSide":
        explanation = "Shortest Side mode resizes the shortest side of the image to match the desired length while maintaining the aspect ratio of the image.";
        break;
      case "Width":
        explanation = "Width mode resizes the width of the image to match the desired width while maintaining the aspect ratio of the image.";
        break;
      case "Height":
        explanation = "Height mode resizes the height of the image to match the desired height while maintaining the aspect ratio of the image.";
        break;
    }
    contentEl.createEl("p", { text: explanation });
    if (["Fit", "Fill"].includes(this.plugin.settings.resizeMode)) {
      const widthInput = new import_obsidian.TextComponent(contentEl).setPlaceholder("Width").setValue(this.plugin.settings.desiredWidth.toString());
      const heightInput = new import_obsidian.TextComponent(contentEl).setPlaceholder("Height").setValue(this.plugin.settings.desiredHeight.toString());
      new import_obsidian.ButtonComponent(contentEl).setButtonText("Save").onClick(async () => {
        const width = parseInt(widthInput.getValue());
        if (/^\d+$/.test(widthInput.getValue()) && width > 0) {
          this.plugin.settings.desiredWidth = width;
        }
        const height = parseInt(heightInput.getValue());
        if (/^\d+$/.test(heightInput.getValue()) && height > 0) {
          this.plugin.settings.desiredHeight = height;
        }
        await this.plugin.saveSettings();
        this.close();
      });
    } else {
      const lengthInput = new import_obsidian.TextComponent(contentEl).setPlaceholder("Enter desired length in pixels").setValue(
        ["LongestSide", "ShortestSide", "Width", "Height"].includes(this.plugin.settings.resizeMode) ? this.plugin.settings.desiredWidth.toString() : this.plugin.settings.desiredHeight.toString()
      );
      new import_obsidian.ButtonComponent(contentEl).setButtonText("Save").onClick(async () => {
        const length = parseInt(lengthInput.getValue());
        if (/^\d+$/.test(lengthInput.getValue()) && length > 0) {
          if (["LongestSide"].includes(this.plugin.settings.resizeMode)) {
            this.plugin.settings.desiredLength = length;
          }
          if (["ShortestSide"].includes(this.plugin.settings.resizeMode)) {
            this.plugin.settings.desiredLength = length;
          }
          if (["Width"].includes(this.plugin.settings.resizeMode)) {
            this.plugin.settings.desiredWidth = length;
          }
          if (["Height"].includes(this.plugin.settings.resizeMode)) {
            this.plugin.settings.desiredHeight = length;
          }
        }
        await this.plugin.saveSettings();
        this.close();
      });
    }
  }
};
